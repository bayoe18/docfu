/**
 * Starlight sidebar generation from DocFu manifest
 *
 * This module contains all Starlight-specific sidebar building logic.
 * It takes the manifest generated by DocFu preprocessing and builds
 * the Starlight sidebar configuration.
 */

/**
 * Generate Starlight sidebar configuration from manifest
 * @param {Object} manifest - Manifest with docs array
 * @param {Object|null} config - docfu.yml configuration
 * @returns {Array|undefined} Starlight sidebar array, or undefined for default autogeneration
 */
export function buildSidebar(manifest, config) {
  if (!manifest || !manifest.docs) {
    return undefined
  }

  const files = manifest.docs || []

  // Explicit sidebar config from _docfu.yml
  if (config?.sidebar && Array.isArray(config.sidebar)) {
    return expandExplicitSidebar(config.sidebar, files)
  }

  // Fallback: auto-generate from directory structure
  return generateAutoSidebar(files)
}

/**
 * Expand explicit sidebar config from docfu.yml
 * Supports: ungrouped items, groups with items, directory autogeneration
 * @param {Array} sidebarConfig - Sidebar configuration from docfu.yml
 * @param {Array} files - Files from manifest
 * @returns {Array} Starlight sidebar configuration
 */
function expandExplicitSidebar(sidebarConfig, files) {
  // Create lookup map for files by path (for matching file references)
  const filesByPath = new Map()
  for (const file of files) {
    // Store by various possible path formats
    filesByPath.set(file.slug, file)
    filesByPath.set(file.slug + '.md', file)
    filesByPath.set(file.slug + '.mdx', file)
    filesByPath.set(file.slug + '.mdoc', file)
  }

  return sidebarConfig.map(entry => {
    // Case 1: Grouped items with directory autogeneration
    if (entry.group && entry.directory) {
      const dir = entry.directory.replace(/\/$/, '') // Remove trailing slash
      const filesInDir = files.filter(f => f.slug.startsWith(dir + '/') || f.slug === dir)

      const result = {
        label: entry.group,
        items: filesInDir.map(f => ({slug: f.slug, label: f.title})),
      }
      if (entry.collapsed !== undefined) result.collapsed = entry.collapsed
      return result
    }

    // Case 2: Grouped items with explicit items array
    if (entry.group && entry.items) {
      const result = {
        label: entry.group,
        items: entry.items.map(item => processItem(item, filesByPath)),
      }
      if (entry.collapsed !== undefined) result.collapsed = entry.collapsed
      return result
    }

    // Case 3: Ungrouped item (appears at sidebar root)
    return processItem(entry, filesByPath)
  })
}

/**
 * Process a single sidebar item (can be string or object)
 * @param {string|Object} item - Item from sidebar config
 * @param {Map} filesByPath - Lookup map for files
 * @returns {Object} Starlight sidebar item
 */
function processItem(item, filesByPath) {
  // Simple string reference: "index.md" or "guides/quickstart.md"
  if (typeof item === 'string') {
    const file = lookupFile(item, filesByPath)
    return {
      slug: file.slug,
      label: file.title,
    }
  }

  // Object with file property: { file: "...", label: "...", badge: ... }
  if (item.file) {
    const file = lookupFile(item.file, filesByPath)
    const result = {
      slug: file.slug,
      label: item.label || file.title,
    }
    if (item.badge) result.badge = normalizeBadge(item.badge)
    return result
  }

  // Fallback: pass through as-is (for custom Starlight config)
  return item
}

/**
 * Look up a file from the manifest by path
 * @param {string} path - File path (with or without extension)
 * @param {Map} filesByPath - Lookup map
 * @returns {Object} File object from manifest
 */
function lookupFile(path, filesByPath) {
  // Try exact match first
  if (filesByPath.has(path)) {
    return filesByPath.get(path)
  }

  // Try without extension (remove .md, .mdx, .mdoc)
  const pathWithoutExt = path.replace(/\.(md|mdx|mdoc)$/, '')
  if (filesByPath.has(pathWithoutExt)) {
    return filesByPath.get(pathWithoutExt)
  }

  // Fallback: create a basic entry (file might be external or not in manifest)
  return {
    slug: pathWithoutExt.toLowerCase(),
    title: pathWithoutExt
      .split('/')
      .pop()
      .replace(/[-_]/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase()),
  }
}

/**
 * Normalize badge to Starlight format
 * @param {string|Object} badge - Badge from config (string or {label, variant})
 * @returns {Object} Starlight badge object
 */
function normalizeBadge(badge) {
  if (typeof badge === 'string') {
    return {text: badge, variant: 'note'}
  }
  return {
    text: badge.label || badge.text,
    variant: badge.variant || 'note',
  }
}

/**
 * Auto-generate sidebar grouped by top-level directories
 * @param {Array} files - Array of file objects with slug, title
 * @returns {Array} Starlight sidebar configuration
 */
function generateAutoSidebar(files) {
  const sidebar = []
  const groups = new Map()

  // Group files by top-level directory
  for (const file of files) {
    const parts = file.slug.split('/')

    if (parts.length === 1) {
      // Root-level file
      sidebar.push({slug: file.slug, label: file.title})
    } else {
      // Nested file - group by first directory
      const topDir = parts[0]
      if (!groups.has(topDir)) {
        groups.set(topDir, [])
      }
      groups.get(topDir).push(file)
    }
  }

  // Add grouped items
  for (const [dir, files] of groups) {
    const label = dir.replace(/[-_]/g, ' ').replace(/\b\w/g, char => char.toUpperCase())
    sidebar.push({
      label,
      items: files.map(f => ({slug: f.slug, label: f.title})),
    })
  }

  return sidebar
}
